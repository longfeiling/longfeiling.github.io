## 变量新定义 let&const
let&const的特点：
1. 在同一个块级作用域下，不允许重复定义
2. const定义的变量不允许二次修改。（对象不受影响）
3. let 和 const 定义的变量会形成块级作用域
4. 不存在变量提升，以及存在暂时性死区

## 函数的变化-箭头函数，剩余参数，参数默认值
箭头函数的规则：
1. 变量只有一个的时候，可以省略（）
2. 如果只有一句返回语句的时候，可以直接省略return
注意：
1. 箭头函数不能作为构造函数
2. 箭头函数没有他自己的this值，箭头函数的this值继承外围作用域
3. 箭头函数没有arguments

### 剩余函数
```
const restParam = function(a, ...args) {
  console.log(args);
};
restParam(1, 2, 3, 4);  // [2, 3, 4]
```
args变量包含了除了a以外的所有参数，这就是所谓的剩余函数。其中运用到的...扩展符。
在使用扩展符的时候要注意，剩余函数的位置要放在最后的，放在中间会报错。
### 默认参数
```
function defaultParam(time = 1000) {
  setTimeout(() => {

  }, time)
}
```

## 数组  解构赋值，二进制数组
>说明：解构赋值无论在数组还是对象中都可以用到
先看下一个例子
```
let [a, b , {name, age}, ...args ] = [1, 2, {name: 'zimo', age: 24}, 3, 4];
console.log(a, b, name, age, args); //1, 2, 'zimo', 24, [3, 4]
```
这个例子有一个特点：*对仗工整*
这就是解构赋值。对于解构来说，左右两边的内容不一致，也不会出现问题的。
```
let [a, b, c] = [1, 2, 3, 4, 5];
console.log(a, b, c) // 1, 2, 3
```
这种情况叫做部分解构。左边也是一样，多出来的部分，会变成undefined
```
let [a,b,c] = [1, 2];
console.log(a, b, c);  //1 2 undefined
```
函数解构要注意的地方：
1. 必须保证有赋值的过程。(不能单独先声明值)
2. 左边内容部分的结构必须与右边保持一致。

## 对象的拓展
1. 可以指定函数参数的默认值
2. rest参数 （...变量名）将所有参数放在一个数组中
3. 规定了函数参数使用了默认值，解构赋值，或者是扩展运算符之后，函数内部就不能够设置严格模式
4. 增加函数的name属性
5. 箭头函数
	* 箭头函数this是指定义时所在的对象，而不是指运行时所在的对象
	* 箭头函数不能够作为构造函数，不能够使用new命令
	* 箭头函数没有arguments这个属性，如果用或者所有参数，用rest函数
	* 不可以用yeild命令，因为不能够作为Genarator函数 
	箭头函数this固定化，并不是因为它内部有绑定this，而是因为函数本身就没有this，所以，this指向外层代码块，所以箭头函数也不能作为构造函数
	箭头函数的代码块部分超过一条，就要用大括号将它们括起来，并且用return语句返回
6. 双冒号（函数绑定）运算符，用来取代call，apply，bind调用, 左边对象，右边函数，该运算符会自动将左边的对象作为上下文执行环境

## 数组的扩展
1. 扩展运算符 ...[1,2,3], 该运算符是将一个数组转化为用空格分割的参数序列
2. Array.from 作用就是将一个类数组对象转化为数组
3. Array.of 作用就是将一组值转化为数组
4. 数组实例的copyWithin() 将制定位置的成员复制到其他位置去，会改变原来的数组
5. 数组实例的find() 找到第一个符合条件的成员，然后返回该成员
6. 数组实例的findIndex() 找到第一个符合条件的成员的位置，然后返回该位置
7. 数组实例的fill() 使用一个定值，填充一个数组
8. 数组实例的keys() , values(), entries() 都是用来遍历数组
9. 数组实例的includes() 表示数组中是否包含给定的值，返回一个布尔类型

## 对象的扩展
1. 属性的简洁表示法 属性简写，方法见血
2. 属性名表达式
3. 方法的name属性
4. Object.is() 比较两个值是否严格相等
5. Object.assign() 用于对象的合并，将源对象的可枚举类型，复制到目标对象
	* 复制的是浅拷贝，目标对象得到的是源对象的引用
	* 同名属性替换
	* 可以用于数组的处理，但是是作为对象来引用

## Promise对象
* es6规定，Promise是一个构造函数，用来生成pormise实例
* promsie实例接收一个函数作为参数，函数有两个参数，resolve和rejected成功和失败后分别要执行的函数
* Promise一旦创建，就立即执行

## 参考
[es6常用知识点概述](https://github.com/laizimo/zimo-article/issues/38)