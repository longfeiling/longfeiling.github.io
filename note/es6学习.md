## 变量新定义 let&const
let&const的特点：
1. 在同一个块级作用域下，不允许重复定义
2. const定义的变量不允许二次修改。（对象不受影响）
3. let 和 const 定义的变量会形成块级作用域
4. 不存在变量提升，以及存在暂时性死区

## 函数的变化-箭头函数，剩余参数，参数默认值
箭头函数的规则：
1. 变量只有一个的时候，可以省略（）
2. 如果只有一句返回语句的时候，可以直接省略return
注意：
1. 箭头函数不能作为构造函数
2. 箭头函数没有他自己的this值，箭头函数的this值继承外围作用域
3. 箭头函数没有arguments

### 剩余函数
```
const restParam = function(a, ...args) {
  console.log(args);
};
restParam(1, 2, 3, 4);  // [2, 3, 4]
```
args变量包含了除了a以外的所有参数，这就是所谓的剩余函数。其中运用到的...扩展符。
在使用扩展符的时候要注意，剩余函数的位置要放在最后的，放在中间会报错。
### 默认参数
```
function defaultParam(time = 1000) {
  setTimeout(() => {

  }, time)
}
```

## 数组  解构赋值，二进制数组
>说明：解构赋值无论在数组还是对象中都可以用到
先看下一个例子
```
let [a, b , {name, age}, ...args ] = [1, 2, {name: 'zimo', age: 24}, 3, 4];
console.log(a, b, name, age, args); //1, 2, 'zimo', 24, [3, 4]
```
这个例子有一个特点：*对仗工整*
这就是解构赋值。对于解构来说，左右两边的内容不一致，也不会出现问题的。
```
let [a, b, c] = [1, 2, 3, 4, 5];
console.log(a, b, c) // 1, 2, 3
```
这种情况叫做部分解构。左边也是一样，多出来的部分，会变成undefined
```
let [a,b,c] = [1, 2];
console.log(a, b, c);  //1 2 undefined
```
函数解构要注意的地方：
1. 必须保证有赋值的过程。(不能单独先声明值)
2. 左边内容部分的结构必须与右边保持一致。


## 参考
[es6常用知识点概述](https://github.com/laizimo/zimo-article/issues/38)