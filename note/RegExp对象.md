## 正则对象的属性和方法
### 属性
与修饰符相关的属性
* ignoreCase: 返回一个布尔值，表示是否设置了i修饰符，可读
* global: 返回一个布尔值，表示是否设置了g修饰符，可读
* multiline: 返回一个布尔值，表示是否设置了m修饰符，可读

与修饰符无关的属性
* lastIndex 返回下一次开始搜索的位置，可读写，在设置了g修饰符是有意义
* source: 返回正则表达式的字符串形式（不包含反斜杠），可读

### 方法
* test() 返回一个布尔值，表示当前模式是否能匹配参数字符串
* exec() 返回匹配结果，如果匹配，返回一个数组，否则，返回null

## 字符串对象的方法
### 方法
* match(): 返回一个数组，成员是所有匹配的子字符串
* search(): 按照给定的正则表达式进行搜索，返回一个整数，表示匹配的位置
* replace(): 按照给定的正则表达式进行替换，返回替换后的字符串
* split(): 按照给定的正则表达式进行字符串分割，返回一个数组，包含分割后的成员

#### String.prototype.match()
字符串对象的match方法对字符串进行正则匹配，返回匹配结果
```
var s = '_x_x_x';
var r1 = /x/;
var r2 = /y/;
console.log(s.match(r1));  //["x"]
console.log(s.match(r2)); //null
```
看上面的例子，与exec()方法类似。
如果正则表达式带有g修饰符，则该方法与exec()方法行为不同,会一次性返回所有匹配成功的结果
```
var s = '_x_x_x';
var r1 = /x/g;
console.log(s.match(r1));  //["x","x","x"]
console.log(r1.exec(s)); //["x"]
```

#### String.prototype.search()
按照给定的正则表达式搜索，返回第一个满足条件的匹配结果在整个字符串的位置，如果没匹配，则返回-1
```
'_x_x'.search(/x/)   //1
```

#### String.prototype.replace(search, replacement)
该方法可以替换匹配的值，它接受两个参数，第一个是正则表达式，第二个参数是替换的内容,返回替换后的字符串
```
'aaa'.replace('a', 'b') // 'baa'
'aaa'.replace(/a/, 'b') // 'baa'
'aaa'.replace(/a/g, 'b') // 'bbb'
```
上面正则表达式中使用了g修饰符，会将所有匹配成功都为替换

replace方法的一个应用，就是消除字符串首尾两端的空格
```
function fn(str) {
  return str.replace(/^\s+|\s+$/g, '')
}
fn(" setetere ")
```
replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容
* $& 指代匹配的子字符串
* $` 指代匹配结果前面的文本
* $' 指代匹配结果后面的文本
* $n 指代匹配成功的第N组内容，n是从1开始的自然数
* $$ 指代美元符号$
```
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')  // "world hello"
'abc'.replace('b', '[$`-$&-$\']');  // "a[a-b-c]c"
```

replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值
```
'3 and 5'.replace(/[0-9]+/g, function(match) {
  return match * 2;
})
// "6 and 10"

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;
a.replace(pattern, function(match) {
  return match.toUpperCase();
})
// "The QUICK BROWN fox jumped over the LAZY dog."
```
作为replace方法第二个参数的函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配(有多少个组匹配，就有多少个对应的参数)。此外，最后还可以多加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。
```
var prices = {
  'pr_1': '$9.11',
  'pr_2': '$9.99',
  'pr_3': '$9.77',
  'pr_4': '$5.00'
};
var templete = '<span id="pr_1"></span>';  // 这里放网页模板字符串

templete.replace(
  /(<span id=")(.*?)(">)(<\/span>)/g,
  function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
  }
);

//"<span id="pr_1">$9.11</span>"
```

#### String.prototype.split()
该方法按照正则规则分割字符串，返回一个由分割后的各部分组成的数组。
接受两个参数，第一个参数是分割规则，第二个参数是返回数组的最大成员数
```
// 非正则分割
'a, b,c,d'.split(',')  // ["a", " b", "c", "d"] 没有将空格去掉

// 正则分割，去掉多余的空格
'a, b,c,d'.split(/, */);  // ["a", "b", "c", "d"]

// 指定返回数组的最大成员
'a, b,c,d'.split(/, */, 2)  // ["a", "b"]
```


```
'aaa*a*'.split(/a*/);  //  ["", "*", "*"]
'aaa**a*'.split(/a*/);  // ["", "*", "*", "*"]
```
上面代码的分割规则是匹配0次或者多次的a,由于正则默认是贪婪匹配，所以例一的第一个分割符是aaa,第二个分割符是a,将字符串分成三个部分，包含开始处的空字符串。
例二的第一个分隔符是aaa,第二个分割符是0个a，第三个分割符是a,所以将字符串分成四个部分

如果正则表达式使用了括号，则括号匹配的部分也会作为数组成员返回
```
'aaa*a*'.split(/(a*)/)   // ["", "aaa", "*", "a", "*"]
'a, b,c'.split(/(, *)/)   // ["a", ", ", "b", ",", "c"]
```


## 匹配规则
正则表达式对字符串的匹配有很复杂的规则
### 字面量字符和元字符
大部分字符在正则表达式中，就是字面的含义，如果某个字符值表示他字面的含义，就叫做字面量字符
```
/cat/.test("dog and cat");  // cat 就是字面量字符
```

除了字面量字符，还有一部分字符有特殊含义，不代表字面意思。他们叫元字符
* 点字符(.) 匹配除回车(\r),换行(\n),行分割符(\u2028),以为的所有字符
* 位置字符 用来提示字符所处的位置，主要有两个位置字符
  * ^ 表示字符的开始位置
  * $ 表示字符的结束位置
```
/^test/.test("test12324");  // true
/test$/.test("new test");  // true
/^test$/.test("test");  // true  // 从开始位置到结束位置只有test
/^test$/.test("test test");  // false
```
* 选择符(|) 在正则表达式中表示"或关系" or
其他的元字符还包括\\、\*、+、?、()、[]、{}等，将在下文解释

### 转义符
正则表达式中那些有特殊含义的字符，如果要匹配他们本身，就需要在它们前面加上反斜杠，比如要匹配加号，则要写成\+
注意，如果使用RegExp方法生成对象，转义需要使用两个斜杠，因为字符串内部会先转义一次

### 特殊字符
* \cX 表示ctrl-[X] 其中x是A-Z中任意一个字母，用来匹配控制字符
* [\b] 匹配退格键(U+00080), 不要与\b混淆
* \n 匹配换行键
* \r 匹配回车键
* \t 匹配制表符tab
* \v 匹配垂直制表符
* \f 匹配换页符
* \0 匹配null 字符
* \xhh 匹配一个以两位十六进制（\x00-\xFF）表示的字符
* \uhhhh 匹配一个以四位十六进制表示的unicode字符

### 字符类
字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有课供选择的字符放在方括号内，如[abc]表示a,b,c中任意选一个匹配
注意，有两个字符在字符类中有特殊含义
1. 脱字符 (^)
如果方括号内的第一个字符是[^],则表示出了字符类之中的字符，其他字符都可以匹配，例如[^abc] 除了a,b，c 外，其他字符都可以匹配
如果方括号内没有其他字符，只有[^]，则表示匹配一切字符,其中包括换行符，而(.)是不包括换行符的。
2. 连字符 (-)
某些情况下，对于连续序列的字符，连字符(-)用例提供简写形式，表示字符的连续范围。比如[A-Z]，可以写成[a-z]
当连字符不出现在方括号之中，就不具备简写的作用，只代表字面含义


### 预定义模式
* \d 匹配0-9之间的任意数字，相当于[0-9]
* \D 匹配0-9以外的字符，相当于[^0-9]
* \w 匹配任意的字母，数字和下划线，相当于[0-9a-zA-Z_]
* \W 匹配除所有字母，数字和下划线以外的字符，相当于[^0-9a-zA-Z_]
* \s 匹配空格（包括制表符，空格符，断行符等, 相当于[\t\r\n\v\f]
* \S 匹配非空格的字符 [^\t\r\n\v\f]
* \b 匹配词的边界
* \B 匹配非词边界 即在词的内部

```
/\s\w*/.exec('hello world');
```

### 重复类
模式的精确匹配次数，使用大括号（{}）表示。{n} 表示恰好重复n次，{n,} 表示至少重复n次，{n,m} 表示至少重复n次，不多于m次

### 量词符
量词符用来设定某个模式出现的次数
* ? 问号表示某个模式出现0次或者1次，等同于{0,1}
* * 星号表示某个模式出现0次或者多次，等同于{0,n}
* + 加号表示某个模式出现1次或者多次，等同于{1,n}

### 贪婪模式
默认情况下是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这种模式成为贪婪模式


## 参考文章
* http://javascript.ruanyifeng.com/stdlib/regexp.html