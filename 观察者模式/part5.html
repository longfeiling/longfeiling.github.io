<!DOCTYPE html>
<html>
<head>
	<title>发布-订阅者模式5</title>
	<meta charset="utf-8">
</head>
<body>

</body>
<script type="text/javascript">
// 上面实现的发布-订阅模式其实还存在两个小问题
// 1. 我们给每一个发布者都添加了listen, trriger方法，造成资源浪费
// 2. 小明和网站之间还存在耦合性，得要知道网站的名称才能够订阅
// 实现一个全局的发布-订阅对象，我们所见的中介
var event = {
	articleList: [],
	listen: function(key, fn) {
		if(!this.articleList[key]) {
			this.articleList[key] = [];
		}
		this.articleList[key].push(fn);
	},
	trriger: function() {
		var key = Array.prototype.shift.call(arguments);
		var fns = this.articleList[key];

		if(!fns || fns.length === 0) {
			return false;
		}

		for(var i = 0, fn; fn = fns[i++];) {
			fn.apply(this, arguments);
		}
	}
}

event.remove = function(key, fn) {
	var fns = this.articleList[key];

	if(!fns) { // 如果key对应的消息没有被人订阅，则直接返回
		return false;
	}

	if(!fn) {  // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅
		fns && (fns.length = 0);
	}else {
		for(var i = 0; i < fns.length-1; i++) {
			var _fn = fns[i];
			if(_fn === fn) {
				fns.splice(i, 1);  // 删除订阅者的回调函数
			}
		}
	}
} 

// 定义一个动态实例化函数，动态安装发布-订阅功能
var initEvent = function(obj) {
	for(var i in event) {
		obj[i] = event[i];
	}
}

var site = {};
initEvent(site);

site.listen("js高级设计模式", fn1 = function(comment) {  // 小明订阅
	console.log('内容=' + comment);
})

site.listen("js高级设计模式", fn2 = function(comment) {  // 小红订阅
	console.log('内容=' + comment);
})

site.remove("js高级设计模式", fn1)
site.trriger("js高级设计模式", "js内容简要")




</script>
</html>